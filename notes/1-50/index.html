<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>짧은글 1-50 | nemorize.me</title>
  <link rel="shortcut icon" href="https://github.com/nemorize.png" />
  <meta name="description" content="@nemorize (Ji Yong, Kim)" />

  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="nemorize.me" />
  <meta property="og:locale" content="ko_KR" />
  <meta property="og:title" content="짧은글 1-50 | nemorize.me" />
  <meta property="og:description" content="@nemorize (Ji Yong, Kim)" />

  <link rel="stylesheet" href="/assets/css/style.css" />
  <link rel="stylesheet" href="/assets/css/notes.css" />
</head>
<body>
<header class="header">
  <div class="container">
    <a class="header__brand" href="/" title="nemorize.me">
      네모라이즈
    </a>
    <nav class="header__nav">
      <a class="header__nav-item" href="/">
        나
      </a>
      <a class="header__nav-item" href="/blog">
        게시글
      </a>
      <a class="header__nav-item" href="/images">
        사진첩
      </a>
      <a class="header__nav-item header__nav-item--active" href="/notes">
        짧은글
      </a>
    </nav>
  </div>
</header>

<main class="notes">
  <div class="container">
    <div class="notes__item" id="note_20">
      <div class="notes__item-header">
        <a href="#note_20">#20</a>
        <time>2025-10-16</time>
      </div>
      <div class="notes__item-body">
        <p>
          최?근 브라우저단 JS에 추가된 기능들 중 제일 만족스러운건 역시 브라우저에서 esm을 쓸 수 있게된 것.
        </p>
        <p>
          구 브라우저 지원을 포기해도 되는 환경에 한해 (지금에 와서는 지원하지 않는 브라우저 버전이 무려 7-8년전 버전의 브라우저) 빌드 없이도 웬만한 건
          다 할 수 있다...
        </p>
        <p>
          특히 PHP 백에 템플릿엔진 프론트를 자주 사용하는 나에겐 정말 달다. 돔 조작 코드들 여기저기 흩어져 스파게티 만들기가 일상이었는데, 브라우저단 JS
          모듈 지원 이후 얘들을 관리할 스택 추가 없이도 정말 깔끔하게 구성할 수 있게 됐다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_19">
      <div class="notes__item-header">
        <a href="#note_19">#19</a>
        <time>2025-10-16</time>
      </div>
      <div class="notes__item-body">
        <p>
          우린 얼마전에 스플래시 화면을 뺐다. 정확하게는... 기술적으로 아예 빼는건 힘들어서ㅎㅎ;
        </p>
        <p>
          초기 네트워크 통신이 다 끝날 때까지 기다리며 몇 초정도 소요되던 스플래시 화면 대기시간을 딱 앱 인스턴스(?) 초기화 시간동안만 출력하도록 해
          쩜몇초 정도로 줄이고, 스켈레톤 UI가 화면 대부분을 잡아먹더라도 일단 메인화면을 띄워주도록 바꿨다.
        </p>
        <p>
          광고 구좌 하나가 줄어든건 역시 좀 뼈아프지만; 사용자 만족도는 엄청 상승했다. 스플래시 화면이 2-3초 정도만 지속되어도 버그같고 답답해 미칠것
          같았는데, 바로바로 뜨니까 너무 만족스럽다더라.
        </p>
        <p>
          어차피 실 사용을 하려면 몇초간 기다려야 하는건 동일한데, 만족도가 다른걸 보면 이런 심리적 요인이 꽤나 크게 적용하는 듯 하다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_18">
      <div class="notes__item-header">
        <a href="#note_18">#18</a>
        <time>2025-10-04</time>
      </div>
      <div class="notes__item-body">
        <p>
          바이브코딩의 단점 중 하나. 프롬프트 작성이 생각을 못 따라온다는 거. 뭘 만들지, 어떻게 만들지는 순식간에 떠오르는데 그걸 프롬프트로 작성하는데엔
          한 세월이 걸린다.
        </p>
        <p>
          물론 직접 코드를 작성하는건 더 오랜 시간이 걸리니, 바이브코딩을 하면 안된다고 이 이야기를 꺼낸건 아니다. 행동보다 생각이 더 느리게 되는 정말 딱
          맞는 상황이 하나 있다.
        </p>
        <p>
          바로 운동할 때. 런닝머신 달리고 있을 땐 힘들고 숨차서 생각하는 속도가 확 떨어진다. 그럼 이 때가 바이브코딩하기 정말 좋은 상황이라고도 볼 수 있지
          않을까?
        </p>
        <p>
          달리면서 말로 프롬프트를 내뱉어 바이브코딩 할 수 있으면 정말 좋을듯. 굳이 키보드가 아닌 음성인식을 써야만 하는 이유도 명확한 상황이다. 일하느라
          바빠서 운동 못함 ㅋㅎㅎ; 같은 핑계를 대지 못하게 하는 부가적인 효과도 얻을 수 있다. 반대로 운동할 때도 일하게 만드는 악덕 기업 행세를 할 수도
          있다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_17">
      <div class="notes__item-header">
        <a href="#note_17">#17</a>
        <time>2025-10-03</time>
      </div>
      <div class="notes__item-body">
        <p>
          GoF를 모를수가 있냐 아니냐...라는 논란이 조금 있는 모양이다.
        </p>
        <p>
          일단 난 GoF라는 표현을 처음 봤다. 팩토리, 빌더, 싱글톤, 어댑터, 파사드, 옵저버 패턴 등등... 이미 잘 사용하고 있지만, 그 중 대표적인 23개
          패턴을 GoF로 묶어 부른다는건 처음 알았다. 그 패턴들을 소개한 ‘디자인 패턴’이라는 유우명한 책의 저자가 4명이라 Gang of Four, GoF라니ㅋ;
          하.. 알고 싶지 않았다...
        </p>
        <p>
          차라리 5CP-5 Creation Patterns, 7SP, 11BP 같은 이름이면 거기에 속한 패턴이 어떤건지 추론해볼수는 있을텐데,
          GoF는ㅋ 전혀 직관적이지 않다. 마치 "PoB는 Products of Baek, 백종원이 팔고 있는 메뉴 중식, 숯불구이, 우동, 커피, 볼카츠를 묶어 부르는
          단어다." 같은 느낌;
        </p>
        <p>
          이미 GoF라는 이름으로 불리고 있으니 이젠 어쩔 수 없겠지만, 난 이런 이름 너무 싫다. 내가 만약 선생이라면 절대 이런 이름으로 안가르칠거다.
          "23개의 대표적인 디자인 패턴" 으로도 충분하다.
        </p>
        <p>
          이쪽 업계는 이름 좀 제대로 지을 필요가 있다...
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_16">
      <div class="notes__item-header">
        <a href="#note_16">#16</a>
        <time>2025-09-03</time>
      </div>
      <div class="notes__item-body">
        <p>
          문피아의 UI 리뉴얼이 참 마음에 든다. 정확하게는, 그들이 새로운 UI를 적용하는 방식이 맘에 든다.
        </p>
        <p>
          의도한 것인지는 모르겠으나, 점진적인 높은 빈도의 UI 개편의 강약 조절이 꽤 능숙하다. 주 사용자층이 이질감을 크게 느끼지 않게 하면서도, 결국
          그들이 최종적으로 원하는 모습에 가까워지는 것이 눈에 띈다. 20년 가까이 이어져온 옛스러운 UI에 아주 익숙해진, 또 UI가 크게 변하면 새로 학습하는
          것에 어려움을 느낄 올드비 세대들도 크게 불편함을 느끼지 않을 아주 사소한 부분부터 디자인을 바꿨다. 그 사소한 변화점마저도 더 이상 어색함을 느끼지
          못할 때 즈음 또 다른 사소한 영역이 새로운 UI로 바뀌어 있다.
        </p>
        <p>
          그러한 변화를 여러번 반복하다, 어느 순간 꽤 중요한 영역을 새로운 디자인으로 바꾼다. 그런데 참 묘하다. 분명 새로운 디자인인데, 과거 디자인이
          아른거리는, 크림 청국장 같은 느낌이라고 해야할까. 묘한 이질감을 가지지만, 신규 유저가 보기에도 기존 유저가 보기에도 참아줄만한, 쓰다보면
          익숙해질만한 정도의 나름 큰 변화를 준다.
        </p>
        <p>
          또 이 변화된 UI에 익숙해져 더 이상 이질감을 느끼지 못할 때가 되니, 동일한 영역에 또 새로운 UI를 가져온다. 그런데 놀랍게도 이질감이 거의 없다.
          작품 두어개 보고 나니 눈에 완전히 익는다. 아직 개편해야 할 화면들이 수 없이 많이 남아있는 상황이라, 화면 간의 통일성은 많이 떨어지는 편이지만
          그렇기에 더 기대가 된다. 다음 화면은 또 어떻게 강약을 조절해 나갈건지 궁금증을 일게 만든다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_15">
      <div class="notes__item-header">
        <a href="#note_15">#15</a>
        <time>2025-08-21</time>
      </div>
      <div class="notes__item-body">
        <p>
          프로그래머에게 있어 바이브코딩의 제일 큰 걸림돌은 재미가 없다는거다. 코드로 문제를 해결해 나가는 행위가 재미있어서 프로그래머가 된건데,
          코드 작성, 문제 해결 전부 AI가 하면 대체 무슨 재미가 있을까?
        </p>
        <p>
          바이브코딩에 재미를 느끼는 프로그래머는, 프로그래밍보단 제품 기획을 업으로 했어야 하는 사람들이 아닐까.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_14">
      <div class="notes__item-header">
        <a href="#note_14">#14</a>
        <time>2025-08-19</time>
      </div>
      <div class="notes__item-body">
        <p>
          2년간 준비한 앱이 곧 찐 프로덕션으로 올라간다. MVP로 빠르게 런칭했어야 했을 앱이었는데, 고객님이든 나든 욕심을 버리지 못하고 너무 크게
          빌드했다는 아쉬움이 있지만... 이미 엎질러진 물, 열심히 해 봐야지.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_13">
      <div class="notes__item-header">
        <a href="#note_13">#13</a>
        <time>2025-07-28</time>
      </div>
      <div class="notes__item-body">
        <p>
          PHP에 파이프 연산자가 추가되기까지 이제 4개월 조금 덜 남았다. 최근 몇년간의 업데이트 중 가장 기대되는 업데이트가 아닐까 싶다.
        </p>
        <p>
          솔직히 이번 파이프 연산자 업데이트에는 아쉬움이 좀 있다. 1개 파라미터를 받는 함수만을 사용할 수 있다는 점이 특히 참 아쉽다. fn 클로저로 감싸지
          않으면 쓰기 힘든 경우가 많을 듯 하다.
        </p>
        <p>
          <code>$str |> str_contains(..., 'needle')</code> 같은 문법이나 <code>$str |> str_contains($value, 'needle')</code>
          같은 문법 정도는 지원할 줄 알았는데, 조금 아쉽다. 프로퍼티 훅에서 이미 <code>$value</code> 라는 일종의 예약 변수명을 만들어 낸 상태에서,
          파라미터 개수를 제한하는 문법으로 결정내린 건 좀 아쉽다. 언제 한번 시간 내서 논의 기록을 읽어봐야겠다.
        </p>
        <p>
          그럼에도 정말 기대된다. 8.4의 프로퍼티 훅은 생각보다 실사용할 일이 적어 아쉬웠는데, 파이프 연산자는 지금 당장도 도입하고 싶어 미칠것만 같은 곳이
          정말 많다ㅎㅎ;
        </p>
        <p>
          8.4 이야기가 나온김에, 8.4의 프로퍼티 훅은 기대했던 것에 비해 아쉬움이 있는 편이다. 이미 다수의 라이브러리, 준표준들이
          <code>withX()</code> 메서드명을 사용한 불변객체 스타일에 정착한 상태라, 생각보다 프로퍼티 훅을 활용할 곳이 많지 않다. 프로퍼티 훅이 적용된
          프로퍼티에 <code>$obj->arr[]=1;</code> 같은 연산을 하지 못하는 것도 한 몫한다.
        </p>
        <p>
          결국 훅과 전통적인 게터세터를 함께 사용해야 하는데, 그럴거면 굳이 훅을 쓸 필요가 있나 싶다. 반대로 비대칭 가시성(asymmetric visibility)
          설정은 생각보다 더 적극적으로 사용하고 있다. 요새 private(set)을 여기저기 싸지르고 있는데, 이렇게 써도 되는지 걱정이 될 정도로 많이 쓰고
          있다. PHP에선 적절한 best practice를 찾기 쉽지 않다. 유사 문법을 일찍 도입한 c#, swift 같은 언어에서 한번 찾아봐야겠다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_12">
      <div class="notes__item-header">
        <a href="#note_12">#12</a>
        <time>2025-07-26</time>
      </div>
      <div class="notes__item-body">
        <p>
          한국어, 일본어, 중국어 등은 한자 문화권의 언어다.
        </p>
        <p>
          한자 문화권의 문자는 밀집도가 꽤 높다. 한 개 문자가 가지는 의미의 밀집도도 높고, 시각적인 밀집도도 꽤 높다. 특히 다른 문자들과 다르게 한글과
          한자는 사각형 공간 안에 글자를 가득가득 채워넣는, 오밀조밀한 고밀도의 문자다. 그래서 한글, 한자를 사용하는 문화권의 문서 양식은 그 문자를 따라
          밀집도가 높은 형태로 발전했다. 공문서, 서적, 웹사이트 등등 문자가 사용되는 영역이라면 빠짐없이 고밀도의 컨텐츠를 지향하는 형태로 발전했다.
        </p>
        <p>
          HWP가 퇴출된다면, 또는 HWP가 애초에 존재하지 않았다면...같은 가정을 해도 저런 도식은 계속 존재할거다. 포토샵, 그림판과 같은 툴을 사용해
          비트맵 이미지 포맷의 도식을 만들어 삽입하겠지. 애초에 도식을 사랑할 수 밖에 없는 언어권, 문화권이니까.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_11">
      <div class="notes__item-header">
        <a href="#note_11">#11</a>
        <time>2025-07-22</time>
      </div>
      <div class="notes__item-body">
        <p>
          <a href="https://www.threads.com/@z.e.r.o.s.u.g.a.r/post/DMSHHQ6TUy3" target="__blank">@z.e.r.o.s.u.g.a.r</a>
          순화어, 다듬은 말은 "누구나 이해하기 쉬운 말"을 목적으로 한다.
          전쟁용어를 청산하기 위함도, 민족성을 철저히 지키기 위해서도, 사회 정의와 기타 사회상규를 지키기 위함이 아니다.
        </p>
        <p>
          "오마카세"라는 표현을 80대 할머니는 잘 이해하지 못할 것이다. 그에 비애 "맡김차림", "주방특선"과 같은 표현은 바로 이해할 수 있을 것이다.
        </p>
        <p>
          다듬은 말은 더 이상 강제성을 띄지 않는 권고안에 불과하다. 일상 생활에 다듬은 말을 쓰지 않으면 반민족 분탕으로 낙인찍는 존재가 아니라,
          "다수의 불특정 청자가 기대되는 상황에서 조금 더 많은 청자가 쉽게 알아들을 수 있는 표현"을 알려주는 일종의 가이드라인이다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_10">
      <div class="notes__item-header">
        <a href="#note_10">#10</a>
        <time>2025-07-10</time>
      </div>
      <div class="notes__item-body">
        <p>
          node:fs의 readdir은 왜 readDir이 아닌걸까?
          readFile은 readFile이면서 readdir은 readDir이 아니다.
          readdir이라는 UNIX 함수명을 따왔다는게 정설이고,
          nodejs 팀에서도 fs 함수 명명법을 `fs.&lt;unix function name&gt;&lt;other stuff&gt;`으로 설명하고 있다.
        </p>
        <p>
          그런데 정작 fs.readdir은 readdir이 아닌 scandir을 사용한다.
          UNIX 함수 중 readdir이라는 이름이 있다는 이유로, 심지어 정작 readdir이 아닌 다른 UNIX 함수를 사용하고 있으면서,
          다른 대부분의 함수 명명법이었던 카멜케이스를 깨트린 상황인거다.
        </p>
        <p>
          여러모로 nodejs 팀 내에서 어떠한 논의 끝에 이러한 결정을 하게 된 것인지 궁금하게 만드는 이름이다.
          고심해서 결정한 것으로 보이는 흔적이 여기저기 남겨져 있지만, 명확한 이유를 언급한 글을 찾지는 못했다.
          언젠가 해당 네이밍에 관여한 사람을 만나면 꼭 물어보고 싶다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_9">
      <div class="notes__item-header">
        <a href="#note_9">#9</a>
        <time>2025-07-06</time>
      </div>
      <div class="notes__item-body">
        <p>
          많은 사람들이 온라인 상 본인인증 절차, 공인인증서 인증 절차에 대해 불평을 하면서도,
          정작 이러한 절차가 "왜 생겨났느냐"에 대해서는 깊이 생각하지 않는다.
          "그냥 빼버리면 되는거 아니냐" 같은 생각을 가진 사람들이 생각보다 꽤 많다.
        </p>
        <p>
          온라인에서의 본인인증, 공동인증서는 "보안"의 목적으로 시행되는 것이 아니다. 각자 "증빙"과 "서명"에 가까운 목적을 가진다.
        </p>
        <p>
          법적으로 만 14세 미만 미성년자의 개인정보를 수집하기 위해서는 법정대리인의 동의가 필요하다.
          그렇다면 당신의 서비스를 이용하는 고객이 만 14세 미만인지 확인할 필요가 있다.
          그걸 제일 잘 해낼 수 있는 방법이 무엇일까? 휴대폰 본인인증이다.
        </p>
        <p>
          법적으로 인감 및 그 증명이 필요한 사무가 있다. 금융, 행정, 법률 관련 업무가 대표적이다. 그러한 사무가 예상되는 곳에서 공인인증서를 요구한다.
          공인인증서는 일종의 "전자적으로 구현된 인감"에 가깝다.
        </p>
        <p>
          온라인 본인인증과 공동인증서를 없애는 일은 정말 쉽지 않다.
          온라인 본인인증을 없애려면 법이 "만 14세 미만의 미성년자도 법정대리인 동의 없이 개인정보를 펑펑 쏴대도 괜찮다"고 바뀌어야 하며,
          공인인증서를 없애려면 법이 "은행에서 도장 없이 통장과 비밀번호만으로 펑펑 출금할 수 있어야 한다"고 바뀌어야 한다.
        </p>
        <p>
          물론 과장된 표현임은 안다. 또, 오프라인 행정 사무가 간소화 되어야 한다고도 생각한다.
          국제적인 정서에 맞지 않기도 하고. (서양권 한정이다. 동양권은 생각보다 유사한 정책들이 꽤 있다.)
          그럼에도 이러한(방향의) 법률 개정이 쉽지 않은 일이고, 1-2년만에 해결될 수 있는 일이 아니라는 것은 명백한 사실이다.
          관련되어 엮인 법률들과 인프라가 상당히 많기 때문에... 십수년 사이즈로 길게 봐야한다.
        </p>
        <p>
          "그냥 빼버리면 되는거 아니냐" 같은 소리를 할 수 있을 정도로 작은 스케일의 일이 아니라는 것을 이야기하고 싶었다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_8">
      <div class="notes__item-header">
        <a href="#note_8">#8</a>
        <time>2025-07-03</time>
      </div>
      <div class="notes__item-body">
        <p>
          본인인증을 해야만 가입할 수 있는 앱을 하나 관리하고 있는데,
          극초창기에 정말 놀라운(?) 이슈를 겪었다.
        </p>
        <p>
          인증 문자를 수신받지 못했다는 문의가 자주 들어오더라.
          본인인증 특성상 메시지 발송을 내 서버에서 처리하는 것도 아니고, 코드를 아무리 뒤져봐도 문제될 점을 찾지 못해 애를 썩였다.
          결국 "정확한 정보를 입력하여 다시 시도해 달라"는 늬앙스의 답변을 할 수 밖에 없었고, 슬프게도 한번 가입에 실패한 그들은 다시 돌아오지 않았다.
        </p>
        <p>
          그러다 우연히 지인이 가입하는 모습을 보며 그제서야 깨달았다.
          이름을 입력하는 란에 본인의 실명이 아니라, 자신이 사용하고자 하는 닉네임을 입력하고 있던 것이다.
          이름/생년월일/성별/전화번호/통신사 를 입력하고 선택하는 UI 구성이라면 당연히 본명을 입력할거라 기대했는데, 전혀 그렇지 않았던거다.
        </p>
        <p>
          "이름" 대신 "이름(실명)" 으로 라벨을 변경하니 관련 문의가 급감했다. 내게 당연한 것이 그들에겐 그렇지 않을 수 있다는걸 다시 한번 깨달았다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_7">
      <div class="notes__item-header">
        <a href="#note_7">#7</a>
        <time>2025-07-03</time>
      </div>
      <div class="notes__item-body">
        <p>
          최근 10년간 PHP 기피현상을 만든 주범은 국내에선 그누보드, 해외에선 워드프레스라고 생각한다.
          그들이 죽지 않는 한 PHP가 다시 부상할 가능성은 0%다. (물론 그들이 죽어도 1% 이상 오르지는 않겠지만;)
        </p>
        <p>
          난 PHP를 꽤 좋아하는 편인데,
          그누보드 코드, 워드프레스 코드 한번 손대고 나면 한동안 PHP의 애정이 팍 식는다...
          조금 더 진심을 담아보자면, 그들이 사용된 코드를 눈에만 담아도 개빡친다. 코드에 불을 붙일 수만 있다면 당장 불질러 버리고 싶을 만큼.
        </p>
        <p>
          워드프레스 그 자체에 대해서는 큰 반감이 없다. 모던하지 않은 코드에 아니꼬움을 느끼지도 않는다.
          오히려 PHP4 시절 C 익스텐션 만들어 운용하던걸 아직까지 유지보수하고 있는 만큼... 사실 닌 모던하지 않은 코드가 더 익숙하다.
          그럼에도 워드프레스와 그누보드가 문제라고 생각하는 것은,
          그것을 사용하는 개발자들 대다수가 강하게 표현해 "제정신이 아닌 코드"를 작성하는데에 거리낌이 없기 때문이다.
          워드프레스, 그누보드 관련 유지보수 의뢰를 지금도 종종 받는다. 이전 개발자들이 작성해 둔 코드를 보면 항상 놀란다.
          SQL 인젝션, XSS 등에 아주 취약한 코드들 뿐이다.
          워드프레스, 그누보드 유지보수 작업 수백건 중 적절한 필터링을 거치는 제품은 손에 꼽을 정도로 적다.
        </p>
        <p>
          escape 없이(또는 빈약하게) raw 쿼리를 실행하는 제품들이 아직까지도 공공연하게 판매되고 있는 시장은 명백하게 잘못된 시장이다.
          물론 다른 언어들, 다른 솔루션에서도 충분히 이러한 문제점을 가질 수 있겠지만, 워드프레스, 그누보드 시장은 심각하다.
          아무런 자정작용 없이 취약점 투성이의 제품을 팔아치우고, 대부분의 에이전시들은 문제의식조차 가지지 못한다.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_6">
      <div class="notes__item-header">
        <a href="#note_6">#6</a>
        <time>2025-07-01</time>
      </div>
      <div class="notes__item-body">
        <p>
          요새 애플 앱스토어 심사가 매우 너그러워진 것 같다.
          좀 더 정확하게는 앱 심사 담당자들이 일을 대충하는 것 같다.
        </p>
        <p>
          특정 일자 이전에 생성된 계정으로는 로그인이 불가능한 버그가 존재하는 업데이트를 심사 넣었는데, 심사 통과했다.
          플레이스토어에서 거절당하지 않았으면 버그를 눈치채지 못하고 배포할 뻔 했다.
        </p>
        <p>
          간단한 앱들은 앱스토어 심사 절차를 일종의 QA 단계로 생각하고 배포하기도 했었는데(ㅎㅎㅎㅎ;;;) 이젠 그러면 안될 것 같다...
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_5">
      <div class="notes__item-header">
        <a href="#note_5">#5</a>
        <time>2025-06-28</time>
      </div>
      <div class="notes__item-body">
        <p>
          한글 파일명은 지양하자.
        </p>
        <p>
          한국 지명에 대응하는 이미지를 출력해야 하는 상황이 있었다.
          iOS와 안드로이드 개발환경에서 정상적으로 출력되는 것을 보고 스테이징 배포를 했는데,
          이상하게 안드로이드 릴리즈 환경(apk)에서만 이미지가 잘못 출력되는 문제가 발생했다.
          expo-image에 유사한 이름의 이미지가 잘못 캐싱되어 잘못된 이미지가 출력되는 버그가 있었다보니,
          그쪽에 포커스를 두고 몇시간동안 코드를 뒤적이고 있었다.
        </p>
        <p>
          하... 결론은 허무했다.
          한국 지명에 대응되는 이미지 에셋을 별 생각 없이 디자이너에게 받은대로 한글 파일명으로 저장해 사용하고 있었는데,
          한글 파일명의 에셋을 제대로 번들링하지 못해 마지막 이미지 하나만 번들링 되고 있더라.
        </p>
        <p>
          proguard 껐다 켰다 해보다 apk 패키지 용량이 예상보다 작게 나와 패키지를 뜯어보고 나서야 깨달았다...
          한글 파일명은 지양하자.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_4">
      <div class="notes__item-header">
        <a href="#note_4">#4</a>
        <time>2025-06-19</time>
      </div>
      <div class="notes__item-body">
        <p>
          <a href="#note_1">#1</a>에서 언급했던 소스코드 유실은 결국 별 의미 없는 이야기가 됐다.
        </p>
        <p>
          기 계약된 유지보수 업체가 뻔히 존재하는데, 윤 정부가 소스코드를 삭제했다는 것도 말이 안되고,
          전 정부의 홈페이지를 리뉴얼 했다는건 당연히 소스코드가 살아있다는 이야기기도 하고.
          이 정부가 전 정부에게 누명을 씌웠다고 해석하고 싶지는 않다. 뭐 특별히 그런 발언을 하게 만든 이유가 어련히 있었겠지.
        </p>
        <p>
          다만 성급한 "소스코드 유실" 발언으로,
        </p>
        <p>
          1. 버전 관리조차 하지 않는 생각없는 한국<br />
          2. 백업조차 하지 않는 생각없는 한국<br />
          3. 접근권한 통제조차 하지 않는 생각없는 한국<br />
          4. 시스템 감사로그 하나 찍지 않는 생각없는 한국<br />
          5. 서버 접속 정보를 포스트잇에 써두고 파쇄하는 한국<br />
          6. 제대로 찾아보지도 않고 보도자료 뿌리는 한국<br />
          중 적어도 하나에 해당한다는걸 온 동네방네 떠들고 다닌게 되었음은 부정할 수 없다...
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_3">
      <div class="notes__item-header">
        <a href="#note_3">#3</a>
        <time>2025-06-19</time>
      </div>
      <div class="notes__item-body">
        <p>
          사이드 프로젝트에서 수파베이스를 걷어냈다.
        </p>
        <p>
          당시 백엔드 작성이 너무 귀찮았던 나머지 수파베이스를 셀프호스팅하여 사용했는데, 어제 밤 아주 큰 맘 먹고 2-3년만에 수파베이스를 걷어냈다.
          근데 걷어내고 보니 백엔드 코드 150줄, 마이그레이션 코드 50줄짜리 작업이더라ㅋㅋ;
        </p>
        <p>
          귀찮다고 아무 생각 없이 SaaS 업어오지 말고, 각 잘 재보고 결정하자.
          언젠간 걷어내야 한다는걸 알면서도, 심지어 그 작업이 크게 어렵지 않을걸 알면서도, 걷어낼 각오를 하기가 쉽지 않다...
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_2">
      <div class="notes__item-header">
        <a href="#note_2">#2</a>
        <time>2025-06-15</time>
      </div>
      <div class="notes__item-body">
        <p>
          <a href="https://www.threads.com/@baameu/post/DK3_aBQSZTm" target="__blank">@baameu</a>
          전문가란 그 분야에서 저지를 수 있는 모든 실수를 해 본 사람이다.
        </p>
        <p>
          이러한 관점에서 SW엔지니어는 다른 직종에 비해 비교적 "저렴하게" 전문가가 될 수 있는(그 문턱이라도 바라볼 수 있는) 직종이라고 생각한다.
          큰 돈 들이지 않고 마음껏 실수해 볼 수 있는 환경을 조성할 수 있게 된 것은 SW엔지니어들에게 정말 큰 축복이다.
        </p>
        <p>
          실수를 하는 환경이 테스트베드라고 하더라도, 전자쟁이, 기계쟁이들은 실수가 곧 부품값으로 직결되고, 요리쟁이등은 실수가 곧 재료값에 직결된다.
          건축쟁이들은 테스트베드를 구축하는 것부터가 아주 큰 비용이 들어가고, 의학, 생물, 화학, 천문학쟁이도 마찬가지다.
        </p>
        <p>
          그에 비해 코드쟁이들은... 전문가까지의 길이 멀고 험하더라도, 거기까지 도달하기 위한 경비가 타 직종 대비 저렴하다는 점은 부정할 수 없다.
        </p>
        <p>
          난 내가 코드쟁이라는 점이 즐겁다. 내 마음껏 실수해볼 수 있는 환경을 원하는대로 조성할 수 있는 분야가 어디 흔한가.
        </p>
      </div>
    </div>
    <div class="notes__item" id="note_1">
      <div class="notes__item-header">
        <a href="#note_1">#1</a>
        <time>2025-06-12</time>
      </div>
      <div class="notes__item-body">
        <p>
          청와대 웹사이트의 소스코드가 유실되었다는 이야기가 있는데, 의아한 부분이 있다.
          청와대에서 사용하던 웹사이트는, 그것의 소스코드가 유실된 상태에서도 정상 작동할 수 있는 구조가 아니다.
        </p>
        <p>
          전통적(?)으로 청와대 웹사이트들은 PHP로 개발되어왔다.
          2000년대 전후에도 워드프레스 내지는 라라벨을 사용했다는 기록이 남아있고, 박근혜, 문재인, 윤석열 정권의 웹사이트 모두 여러 곳에서 PHP의 흔적을 찾아볼 수 있다.
        </p>
        <p>
          그래서 정말 의아하다. PHP는 소스코드가 곧 웹사이트가 되는 언어다.
          PHP 웹사이트에서 소스코드가 유실되었다는 말은, 그냥 웹사이트 자체가 완전히 망가졌다는 이야기가 된다. 그러나 윤석열이 파면당한 당일까지 웹사이트가 멀쩡히 운용되고 있었으며, 그 이후 점검중인 상태로 존재하다 4/28 윤석열의 정보가 빠진 웹사이트가 다시 열렸다.
          파면 이후로도 정상적으로 웹사이트가 운용되고 있었는데, 소스 코드가 유실되었다는 이야기는 정말 의아하다.
        </p>
      </div>
    </div>
  </div>
</main>

<footer class="footer">
  <div class="container">
    <p class="footer__copyright">
      &copy; 2025 Ji Yong, Kim. All rights reserved.
    </p>
    <nav class="footer__nav">
      <a class="footer__nav-item" href="/tools">
        도구함
      </a>
      <a class="footer__nav-item" href="/licenses">
        라이선스
      </a>
      <a class="footer__nav-item" href="https://github.com/nemorize" target="_blank">
        GitHub
      </a>
    </nav>
  </div>
</footer>
</body>
</html>
